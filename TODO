√ META6.json
√ New dependency: https://github.com/timo/cairo-p6
√ Feature Request: GTK::TextBuffer.buffer to accept from Str or Buf when setting text
√ METHOD ALIASING! - This has mostly been accomplished, but in the case of container-based classes and others where manual aliasing was done, the best thing to do would be a proto method. See: https://gist.github.com/Xliff/34b9d2e3e27c76696ec60e6791075634
√ Convert Perl6 additions to GTK::Container into a role. (done as GTK::Roles::LatchedContainer)
√ Convert Perl6 additions to GTK::Box into a role. (GTK::Roles::Boxable)
√ Investivate the use of g_object_getv and g_object_setv to access previously non-accessible GObject properties. See https://developer.gnome.org/gobject/stable/gobject-The-Base-Object-Type.html#g-object-get
√ Fix lack of icons in GTK::IconView
√ Consider refactoring scripts/build-mro.pl6 to generate both widget and non-widget MRO lists.
√ Move GTK::Window title and size initialization to BUILD                   (implemented, but not tested)
√ A mechanism for emitting ALL defined handlers (methods in GTL::Roles::Signals::* )
+ Since build.sh is now running scripts/dependencies.pl6 find a way to make it do the full run only if necessary
+ Mechanism for providing PROPER event handlers for all events (in progress...)
+ Add-to-project-if-I'm-completely-insane: GVariant
+ GTK::ScrolledWindow.new_with_policy is in desperate need of being written (implemented, but not tested)
+ GTK::Container.set/get-child-properties using var args. Hint: *@slurpys!  (implemented, but not tested)
+ Add GTK::Compat::Action (GAction)
+ Add type specific signal handling to GTK::Notebook                        (implemented, but not tested)
+ Add a working GList implementation
  - Test latest inplementation of GTK::Compat::GList and GTK::Roles::ListData
+ Generate GTK::Widgets and GTK::NonWidgets comprised of need statements (build-mro.pl6 could do this)
  - build-mro.pl6 is now doing this.
- Insure all method-level gchar paramters are converted to Str()
- COMPLETE a working GSList implementation
- GDK
  - Refinements to all GTK::Compat::Objects
	- Finish refinements on GTK::Compat::Window
  - Rename all GDK objects from GTK::Compat::
- Separate all GTK::Compat::Pixbuf files into it's own project, that will become a dependency. GDK::Pixbuf is available.
- Move signals to %Object.signal<name> to fix issue with method name conflicts
- Add attribute 'control' to GTK::Stack to allow adding either GtkStackSwitcher or GtkStackSidebar
- Add overflow warnings to appropriate RESOLVE routines in GTK::Roles::Types. Said warnings are NOT under $DEBUG check.
- Inhibit pass-through to Mu constructor in all widget-based objects!
- Add this to the top of all activate blocks in t/
    CATCH { default { .message.say; $app.exit } }
- Rewrite this document in Markdown format.
- Improve GTK::Widget.CreateObject to take best guess at pointer name for widget type, if it exists.
- GTK::Grid to provide sanitized version of it's tracking structure to user-code
- Properly rename GtkCssSection to GtkCSSSection
- Refine GTK::Compat::Window
- GTK::Roles::Data should be deprecated in favor of GTK::Roles::Properties
- Is there any further need for GTK::Roles::Types.RESOLVE-* now that those routines have been moved to GTK::Raw::Utils.
  If the answer is NO, then it is an EXTREMELY LOW PRIORITY refactor. Don't rock the boat unless it's leaking.
- Consider abstracting GTK::Roles::Protection into it's own project. Method::Protect, maybe?
- Properly rework GTK::Utils::MenuBuilder. It is faulty
  + Test case for all features of GTK::Utils::MenuBuilder
- For ALL type coercer methods, insure they are aliased to a proper object-specific nickname
- Add an implementation for GTK::Compat::Closure (GClosure)
- Roll GTK::Roles::References into GTK::Roles::Object
- Consider having GTK::Roles::Properties do GTK::Roles::Object (could rolling properties into objects be a thing?)
- For all widgets: Replace all static strings in self.setType() with self.^name.
- Investigate all async *_finish routines to see if a multi with a simpler interface is possible.
- Add registration system to GTK::Builder, since type names will mostly start with Gtk..., must have a way to convert those
  names to the proper object name. Propose <Project>::Builder::Registry, with static .register method that provides
  pair mapping detected_name => proper_name.
- Complete implementation of GTK::Compat::Roles::GFile, as well as it's companion wrapper GTK::Compat::File and also GTK::Compat::Raw::FileTypes
- Finish GTK::Utils::LockedHash
- Implement GTK::Compat::ActionEntry
* Implement GTK::ApplicationWindow
- Implement GTK::Roles::RecentChooser...
  ...and
    ...GTK::RecentChooserMenu,
    ...GTK::Dialog::RecentChooser,
    ...GTK::RecentChooserMenu,
    ...GTK::RecentChooserWidget!
- Consider altering scripts/dirty_typing.pl6 to only go through files later the latest date amongst the stubs in in .dirty_typing
- Considfer altering scripts/dependencies.pl6 to exit if a module name is listed as a dependency but has no node. If this does occur, report discrepancy and the module(s) where it appeared.
- Roles can now compose submethod DESTROY. So now pointer-level GC is possible, see:
  * perl6 -e 'use NativeCall; role B { submethod DESTROY { say "BOO!" } }; class A is repr<CPointer> { also does B; }; my $a = A.new; $a = 1; for ^10 { my @a = rand xx 100000; say +@a }
- NEW INITIATIVE: Where returning a GList or GSList, offer a :$raw option to allow list of CPointer objects to be returned.

* PERFORMANCE NOTE
	- It is faster to use 'if $a.defined' rather than 'with $a' if you DO NOT need to topicalize $a.
	- If trying to test for definedness of two or more variables, nesting with statements is faster than using a junction or 'andthen'

Applications
============
√ A text editor in Perl6. Think about using it as a visual Regex tester (in progress, see p6-VisualGrammar.git)
+ Glade UI to p6-GtkPerl application (in progress see GTK::Builder:: objects and ui-to-code.pl6)
√ A Perl6 port of http://gtklipsum.sourceforge.net/ (a better version of t/41-textview-scrolling.t)
